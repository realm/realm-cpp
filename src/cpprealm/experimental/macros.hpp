#ifndef CPPREALM_MACROS_HPP
#define CPPREALM_MACROS_HPP

#define FE_0(WHAT, cls)
#define FE_1(WHAT, cls, X) WHAT(cls, X)
#define FE_2(WHAT, cls, X, ...) WHAT(cls, X)FE_1(WHAT, cls, __VA_ARGS__)
#define FE_3(WHAT, cls, X, ...) WHAT(cls, X)FE_2(WHAT, cls, __VA_ARGS__)
#define FE_4(WHAT, cls, X, ...) WHAT(cls, X)FE_3(WHAT, cls, __VA_ARGS__)
#define FE_5(WHAT, cls, X, ...) WHAT(cls, X)FE_4(WHAT, cls, __VA_ARGS__)
#define FE_6(WHAT, cls, X, ...) WHAT(cls, X)FE_5(WHAT, cls, __VA_ARGS__)
#define FE_7(WHAT, cls, X, ...) WHAT(cls, X)FE_6(WHAT, cls, __VA_ARGS__)
#define FE_8(WHAT, cls, X, ...) WHAT(cls, X)FE_7(WHAT, cls, __VA_ARGS__)
#define FE_9(WHAT, cls, X, ...) WHAT(cls, X)FE_8(WHAT, cls, __VA_ARGS__)
#define FE_10(WHAT, cls, X, ...) WHAT(cls, X)FE_9(WHAT, cls, __VA_ARGS__)
#define FE_11(WHAT, cls, X, ...) WHAT(cls, X)FE_10(WHAT, cls, __VA_ARGS__)
#define FE_12(WHAT, cls, X, ...) WHAT(cls, X)FE_11(WHAT, cls, __VA_ARGS__)
#define FE_13(WHAT, cls, X, ...) WHAT(cls, X)FE_12(WHAT, cls, __VA_ARGS__)
#define FE_14(WHAT, cls, X, ...) WHAT(cls, X)FE_13(WHAT, cls, __VA_ARGS__)
#define FE_15(WHAT, cls, X, ...) WHAT(cls, X)FE_14(WHAT, cls, __VA_ARGS__)
#define FE_16(WHAT, cls, X, ...) WHAT(cls, X)FE_15(WHAT, cls, __VA_ARGS__)
#define FE_17(WHAT, cls, X, ...) WHAT(cls, X)FE_16(WHAT, cls, __VA_ARGS__)
#define FE_18(WHAT, cls, X, ...) WHAT(cls, X)FE_17(WHAT, cls, __VA_ARGS__)
#define FE_19(WHAT, cls, X, ...) WHAT(cls, X)FE_18(WHAT, cls, __VA_ARGS__)
#define FE_20(WHAT, cls, X, ...) WHAT(cls, X)FE_19(WHAT, cls, __VA_ARGS__)
#define FE_21(WHAT, cls, X, ...) WHAT(cls, X)FE_20(WHAT, cls, __VA_ARGS__)
#define FE_22(WHAT, cls, X, ...) WHAT(cls, X)FE_21(WHAT, cls, __VA_ARGS__)
#define FE_23(WHAT, cls, X, ...) WHAT(cls, X)FE_22(WHAT, cls, __VA_ARGS__)
#define FE_24(WHAT, cls, X, ...) WHAT(cls, X)FE_23(WHAT, cls, __VA_ARGS__)
#define FE_25(WHAT, cls, X, ...) WHAT(cls, X)FE_24(WHAT, cls, __VA_ARGS__)
#define FE_26(WHAT, cls, X, ...) WHAT(cls, X)FE_25(WHAT, cls, __VA_ARGS__)
#define FE_27(WHAT, cls, X, ...) WHAT(cls, X)FE_26(WHAT, cls, __VA_ARGS__)
#define FE_28(WHAT, cls, X, ...) WHAT(cls, X)FE_27(WHAT, cls, __VA_ARGS__)
#define FE_29(WHAT, cls, X, ...) WHAT(cls, X)FE_28(WHAT, cls, __VA_ARGS__)
#define FE_30(WHAT, cls, X, ...) WHAT(cls, X)FE_29(WHAT, cls, __VA_ARGS__)
#define FE_31(WHAT, cls, X, ...) WHAT(cls, X)FE_30(WHAT, cls, __VA_ARGS__)
#define FE_32(WHAT, cls, X, ...) WHAT(cls, X)FE_31(WHAT, cls, __VA_ARGS__)
#define FE_33(WHAT, cls, X, ...) WHAT(cls, X)FE_32(WHAT, cls, __VA_ARGS__)
#define FE_34(WHAT, cls, X, ...) WHAT(cls, X)FE_33(WHAT, cls, __VA_ARGS__)
#define FE_35(WHAT, cls, X, ...) WHAT(cls, X)FE_34(WHAT, cls, __VA_ARGS__)
#define FE_36(WHAT, cls, X, ...) WHAT(cls, X)FE_35(WHAT, cls, __VA_ARGS__)
#define FE_37(WHAT, cls, X, ...) WHAT(cls, X)FE_36(WHAT, cls, __VA_ARGS__)
#define FE_38(WHAT, cls, X, ...) WHAT(cls, X)FE_37(WHAT, cls, __VA_ARGS__)
#define FE_39(WHAT, cls, X, ...) WHAT(cls, X)FE_38(WHAT, cls, __VA_ARGS__)
#define FE_40(WHAT, cls, X, ...) WHAT(cls, X)FE_39(WHAT, cls, __VA_ARGS__)
#define FE_41(WHAT, cls, X, ...) WHAT(cls, X)FE_40(WHAT, cls, __VA_ARGS__)
#define FE_42(WHAT, cls, X, ...) WHAT(cls, X)FE_41(WHAT, cls, __VA_ARGS__)
#define FE_43(WHAT, cls, X, ...) WHAT(cls, X)FE_42(WHAT, cls, __VA_ARGS__)
#define FE_44(WHAT, cls, X, ...) WHAT(cls, X)FE_43(WHAT, cls, __VA_ARGS__)
#define FE_45(WHAT, cls, X, ...) WHAT(cls, X)FE_44(WHAT, cls, __VA_ARGS__)
#define FE_46(WHAT, cls, X, ...) WHAT(cls, X)FE_45(WHAT, cls, __VA_ARGS__)
#define FE_47(WHAT, cls, X, ...) WHAT(cls, X)FE_46(WHAT, cls, __VA_ARGS__)
#define FE_48(WHAT, cls, X, ...) WHAT(cls, X)FE_47(WHAT, cls, __VA_ARGS__)
#define FE_49(WHAT, cls, X, ...) WHAT(cls, X)FE_48(WHAT, cls, __VA_ARGS__)
#define FE_50(WHAT, cls, X, ...) WHAT(cls, X)FE_49(WHAT, cls, __VA_ARGS__)
#define FE_51(WHAT, cls, X, ...) WHAT(cls, X)FE_50(WHAT, cls, __VA_ARGS__)
#define FE_52(WHAT, cls, X, ...) WHAT(cls, X)FE_51(WHAT, cls, __VA_ARGS__)
#define FE_53(WHAT, cls, X, ...) WHAT(cls, X)FE_52(WHAT, cls, __VA_ARGS__)
#define FE_54(WHAT, cls, X, ...) WHAT(cls, X)FE_53(WHAT, cls, __VA_ARGS__)
#define FE_55(WHAT, cls, X, ...) WHAT(cls, X)FE_54(WHAT, cls, __VA_ARGS__)
#define FE_56(WHAT, cls, X, ...) WHAT(cls, X)FE_55(WHAT, cls, __VA_ARGS__)
#define FE_57(WHAT, cls, X, ...) WHAT(cls, X)FE_56(WHAT, cls, __VA_ARGS__)
#define FE_58(WHAT, cls, X, ...) WHAT(cls, X)FE_57(WHAT, cls, __VA_ARGS__)
#define FE_59(WHAT, cls, X, ...) WHAT(cls, X)FE_58(WHAT, cls, __VA_ARGS__)
#define FE_60(WHAT, cls, X, ...) WHAT(cls, X)FE_59(WHAT, cls, __VA_ARGS__)
#define FE_61(WHAT, cls, X, ...) WHAT(cls, X)FE_60(WHAT, cls, __VA_ARGS__)
#define FE_62(WHAT, cls, X, ...) WHAT(cls, X)FE_61(WHAT, cls, __VA_ARGS__)
#define FE_63(WHAT, cls, X, ...) WHAT(cls, X)FE_62(WHAT, cls, __VA_ARGS__)
#define FE_64(WHAT, cls, X, ...) WHAT(cls, X)FE_63(WHAT, cls, __VA_ARGS__)
#define FE_65(WHAT, cls, X, ...) WHAT(cls, X)FE_64(WHAT, cls, __VA_ARGS__)
#define FE_66(WHAT, cls, X, ...) WHAT(cls, X)FE_65(WHAT, cls, __VA_ARGS__)
#define FE_67(WHAT, cls, X, ...) WHAT(cls, X)FE_66(WHAT, cls, __VA_ARGS__)
#define FE_68(WHAT, cls, X, ...) WHAT(cls, X)FE_67(WHAT, cls, __VA_ARGS__)
#define FE_69(WHAT, cls, X, ...) WHAT(cls, X)FE_68(WHAT, cls, __VA_ARGS__)
#define FE_70(WHAT, cls, X, ...) WHAT(cls, X)FE_69(WHAT, cls, __VA_ARGS__)
#define FE_71(WHAT, cls, X, ...) WHAT(cls, X)FE_70(WHAT, cls, __VA_ARGS__)
#define FE_72(WHAT, cls, X, ...) WHAT(cls, X)FE_71(WHAT, cls, __VA_ARGS__)
#define FE_73(WHAT, cls, X, ...) WHAT(cls, X)FE_72(WHAT, cls, __VA_ARGS__)
#define FE_74(WHAT, cls, X, ...) WHAT(cls, X)FE_73(WHAT, cls, __VA_ARGS__)
#define FE_75(WHAT, cls, X, ...) WHAT(cls, X)FE_74(WHAT, cls, __VA_ARGS__)
#define FE_76(WHAT, cls, X, ...) WHAT(cls, X)FE_75(WHAT, cls, __VA_ARGS__)
#define FE_77(WHAT, cls, X, ...) WHAT(cls, X)FE_76(WHAT, cls, __VA_ARGS__)
#define FE_78(WHAT, cls, X, ...) WHAT(cls, X)FE_77(WHAT, cls, __VA_ARGS__)
#define FE_79(WHAT, cls, X, ...) WHAT(cls, X)FE_78(WHAT, cls, __VA_ARGS__)
#define FE_80(WHAT, cls, X, ...) WHAT(cls, X)FE_79(WHAT, cls, __VA_ARGS__)
#define FE_81(WHAT, cls, X, ...) WHAT(cls, X)FE_80(WHAT, cls, __VA_ARGS__)
#define FE_82(WHAT, cls, X, ...) WHAT(cls, X)FE_81(WHAT, cls, __VA_ARGS__)
#define FE_83(WHAT, cls, X, ...) WHAT(cls, X)FE_82(WHAT, cls, __VA_ARGS__)
#define FE_84(WHAT, cls, X, ...) WHAT(cls, X)FE_83(WHAT, cls, __VA_ARGS__)
#define FE_85(WHAT, cls, X, ...) WHAT(cls, X)FE_84(WHAT, cls, __VA_ARGS__)
#define FE_86(WHAT, cls, X, ...) WHAT(cls, X)FE_85(WHAT, cls, __VA_ARGS__)
#define FE_87(WHAT, cls, X, ...) WHAT(cls, X)FE_86(WHAT, cls, __VA_ARGS__)
#define FE_88(WHAT, cls, X, ...) WHAT(cls, X)FE_87(WHAT, cls, __VA_ARGS__)
#define FE_89(WHAT, cls, X, ...) WHAT(cls, X)FE_88(WHAT, cls, __VA_ARGS__)
#define FE_90(WHAT, cls, X, ...) WHAT(cls, X)FE_89(WHAT, cls, __VA_ARGS__)
#define FE_91(WHAT, cls, X, ...) WHAT(cls, X)FE_90(WHAT, cls, __VA_ARGS__)
#define FE_92(WHAT, cls, X, ...) WHAT(cls, X)FE_91(WHAT, cls, __VA_ARGS__)
#define FE_93(WHAT, cls, X, ...) WHAT(cls, X)FE_92(WHAT, cls, __VA_ARGS__)
#define FE_94(WHAT, cls, X, ...) WHAT(cls, X)FE_93(WHAT, cls, __VA_ARGS__)
#define FE_95(WHAT, cls, X, ...) WHAT(cls, X)FE_94(WHAT, cls, __VA_ARGS__)
#define FE_96(WHAT, cls, X, ...) WHAT(cls, X)FE_95(WHAT, cls, __VA_ARGS__)
#define FE_97(WHAT, cls, X, ...) WHAT(cls, X)FE_96(WHAT, cls, __VA_ARGS__)
#define FE_98(WHAT, cls, X, ...) WHAT(cls, X)FE_97(WHAT, cls, __VA_ARGS__)
#define FE_99(WHAT, cls, X, ...) WHAT(cls, X)FE_98(WHAT, cls, __VA_ARGS__)

#define GET_MACRO(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, \
    _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26,\
    _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,\
    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54,\
    _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68,\
    _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82,\
    _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, NAME, ...) NAME

#define FOR_EACH(action, cls, ...) \
  GET_MACRO(_0, __VA_ARGS__,        \
        FE_99, FE_98, FE_97, FE_96, FE_95, FE_94, FE_93, FE_92, FE_91, FE_90, FE_89, FE_88, \
        FE_87, FE_86, FE_85, FE_84, FE_83, FE_82, FE_81, FE_80, FE_79, FE_78, FE_77, FE_76, \
        FE_75, FE_74, FE_73, FE_72, FE_71, FE_70, FE_69, FE_68, FE_67, FE_66, FE_65, FE_64, \
        FE_63, FE_62, FE_61, FE_60, FE_59, FE_58, FE_57, FE_56, FE_55, FE_54, FE_53, FE_52, \
        FE_51, FE_50, FE_49, FE_48, FE_47, FE_46, FE_45, FE_44, FE_43, FE_42, FE_41, FE_40, \
        FE_39, FE_38, FE_37, FE_36, FE_35, FE_34, FE_33, FE_32, FE_31, FE_30, FE_29, FE_28, \
        FE_27, FE_26, FE_25, FE_24, FE_23, FE_22, FE_21, FE_20, FE_19, FE_18, FE_17, FE_16, \
        FE_15, FE_14, FE_13, FE_12, FE_11, FE_10, FE_9, FE_8, FE_7, FE_6, FE_5, FE_4, FE_3, \
        FE_2, FE_1, FE_0)(action, cls, __VA_ARGS__)

#define DECLARE_PERSISTED(cls, property) managed<decltype(cls::property)> property;
#define DECLARE_PROPERTY(cls, p) realm::property<&cls::p>(#p),
#define DECLARE_MANAGED_PROPERTY(cls, p) &realm::experimental::managed<cls>::p,
#define DECLARE_UNMANAGED_TO_MANAGED_PAIR(cls, p) std::pair {&cls::p, &realm::experimental::managed<cls>::p},
#define DECLARE_MANAGED_PROPERTY_NAME(cls, p) #p,
#define DECLARE_COND_PROPERTY_VALUE_FOR_NAME(cls, p) if (_name == #p) { auto ptr = &managed<cls>::p; return (*this.*ptr).value(); }
#define DECLARE_COND_UNMANAGED_TO_MANAGED(cls, p) if constexpr (std::is_same_v<decltype(ptr), decltype(&cls::p)>) { return &managed<cls>::p; }

#include <utility>

#define COUNTER_READ_CRUMB( TAG, RANK, ACC ) \
    counter_crumb( TAG(), constant_index< RANK >(), constant_index< ACC >() )
#define COUNTER_READ( TAG ) COUNTER_READ_CRUMB( TAG, 1, COUNTER_READ_CRUMB( TAG, 2, COUNTER_READ_CRUMB( TAG, 4, COUNTER_READ_CRUMB( TAG, 8, \
    COUNTER_READ_CRUMB( TAG, 16, COUNTER_READ_CRUMB( TAG, 32, COUNTER_READ_CRUMB( TAG, 64, COUNTER_READ_CRUMB( TAG, 128, 0 ) ) ) ) ) ) ) )

#define COUNTER_INC( TAG ) \
constant_index< COUNTER_READ( TAG ) + 1 > \
constexpr counter_crumb( TAG, constant_index< ( COUNTER_READ( TAG ) + 1 ) & ~ COUNTER_READ( TAG ) >, \
          					constant_index< ( COUNTER_READ( TAG ) + 1 ) & COUNTER_READ( TAG ) > ) { return {}; }

#define COUNTER_LINK_NAMESPACE( NS ) using counter_crumb;

template< std::size_t n >
struct constant_index : std::integral_constant< std::size_t, n > {};

template< typename id, std::size_t rank, std::size_t acc >
constexpr constant_index< acc > counter_crumb( id, constant_index< rank >, constant_index< acc > ) { return {}; } // found by ADL via constant_index

#include <cpprealm/internal/bridge/object.hpp>
#include <cpprealm/internal/bridge/realm.hpp>
#include <cpprealm/internal/bridge/col_key.hpp>
#include <cpprealm/internal/bridge/obj.hpp>
#include <cpprealm/internal/bridge/property.hpp>
#include <cpprealm/internal/bridge/query.hpp>

namespace realm::experimental {
    struct managed_base {
        managed_base() = default;
        managed_base(const managed_base& other) {
            m_obj = other.m_obj;
            m_realm = other.m_realm;
            m_key = other.m_key;
            // MARK: Queries
            should_detect_usage_for_queries = other.should_detect_usage_for_queries;
            query = other.query;
        }
        managed_base& operator=(const managed_base& other) {
            m_obj = other.m_obj;
            m_realm = other.m_realm;
            m_key = other.m_key;
            // MARK: Queries
            should_detect_usage_for_queries = other.should_detect_usage_for_queries;
            query = other.query;
            return *this;
        }
        managed_base(managed_base&& other) {
            m_obj = std::move(other.m_obj);
            m_realm = std::move(other.m_realm);
            m_key = std::move(other.m_key);
            // MARK: Queries
            should_detect_usage_for_queries = std::move(other.should_detect_usage_for_queries);
            query = std::move(other.query);
        }
        managed_base& operator=(managed_base&& other) {
            m_obj = std::move(other.m_obj);
            m_realm = std::move(other.m_realm);
            m_key = std::move(other.m_key);
            // MARK: Queries
            should_detect_usage_for_queries = std::move(other.should_detect_usage_for_queries);
            query = std::move(other.query);
            return *this;
        }
        ~managed_base() {
            m_obj = nullptr;
            m_realm = nullptr;
            m_key.~col_key();
            should_detect_usage_for_queries = false;
            query = nullptr;
        }

        static constexpr bool is_object = false;
        internal::bridge::obj *m_obj = nullptr;
        internal::bridge::realm *m_realm = nullptr;
        internal::bridge::col_key m_key;
        // MARK: Queries
        bool should_detect_usage_for_queries = false;
        internal::bridge::query* query = nullptr;

        void assign(internal::bridge::obj *obj,
                    internal::bridge::realm* realm,
                    internal::bridge::col_key &&key) {
            this->m_obj = obj;
            this->m_realm = realm;
            this->m_key = key;
        }

        void assign(internal::bridge::obj *obj,
                    internal::bridge::realm* realm,
                    const internal::bridge::col_key &key) {
            this->m_obj = obj;
            this->m_realm = realm;
            this->m_key = key;
        }

        template<typename T>
        managed_base& operator =(const T& v) {
            if constexpr (std::is_same_v<T, std::nullopt_t>) {
                m_obj->set_null(m_key);
            } else {
                m_obj->template set<typename internal::type_info::type_info<T, void>::internal_type>(m_key, v);
            }
            return *this;
        }

        void prepare_for_query(internal::bridge::query& query_builder) {
            should_detect_usage_for_queries = true;
            query = &query_builder;
        }

        void prepare_for_query(internal::bridge::realm* realm,
                               const internal::bridge::table& table,
                               const std::string& col_name) {
            this->query = new internal::bridge::query(table);
            this->m_realm = realm;
            this->m_key = table.get_column_key(col_name);
            this->should_detect_usage_for_queries = true;
        }
    };

    template<typename T, typename = void>
    struct managed;
}

#define __cpprealm_build_experimental_query(op, name, type) \
rbool managed<type>::operator op(const type& rhs) const noexcept { \
    if (this->should_detect_usage_for_queries) { \
        auto query = internal::bridge::query(this->query->get_table()); \
        query.name(this->m_key, serialize(rhs)); \
        return query; \
    } \
    return serialize(value()) op serialize(rhs); \
} \

#define __cpprealm_build_optional_experimental_query(op, name, type) \
rbool managed<std::optional<type>>::operator op(const std::optional<type>& rhs) const noexcept { \
    if (this->should_detect_usage_for_queries) { \
        auto query = internal::bridge::query(this->query->get_table()); \
        if (auto r = serialize(rhs)) { \
            query.name(this->m_key, *r); \
        } else { \
            query.name(this->m_key, std::nullopt); \
        } \
        return query; \
    } \
    return serialize(value()) op serialize(rhs); \
} \

#define REALM_SCHEMA(cls, ...) \
    DECLARE_REALM_SCHEMA(cls, false, false, experimental::BetaObjectType::TopLevel, __VA_ARGS__) \

#define REALM_EMBEDDED_SCHEMA(cls, ...) \
    DECLARE_REALM_SCHEMA(cls, true, false, experimental::BetaObjectType::Embedded, __VA_ARGS__)

#define REALM_ASYMMETRIC_SCHEMA(cls, ...) \
    DECLARE_REALM_SCHEMA(cls, false, true, experimental::BetaObjectType::Asymmetric, __VA_ARGS__)

#define DECLARE_REALM_SCHEMA(cls, is_embedded_object, is_asymmetric_object, beta_object_type, ...) \
    template <> struct managed<cls> { \
        managed() = default; \
        static constexpr experimental::BetaObjectType object_type = beta_object_type;     \
        FOR_EACH(DECLARE_PERSISTED, cls, __VA_ARGS__) \
        static constexpr auto schema = realm::schema(#cls, beta_object_type, std::tuple{ FOR_EACH(DECLARE_PROPERTY, cls, __VA_ARGS__) }  ); \
        static constexpr auto managed_pointers() { \
            return std::tuple{FOR_EACH(DECLARE_MANAGED_PROPERTY, cls, __VA_ARGS__)};  \
        }                                                                                          \
        template <typename PtrType> static constexpr auto unmanaged_to_managed_pointer(PtrType ptr) {         \
           FOR_EACH(DECLARE_COND_UNMANAGED_TO_MANAGED, cls, __VA_ARGS__);  \
        } \
        static constexpr auto managed_pointers_names = std::tuple{FOR_EACH(DECLARE_MANAGED_PROPERTY_NAME, cls, __VA_ARGS__)}; \
        internal::bridge::obj m_obj;\
        internal::bridge::realm m_realm;                                                           \
        bool m_prepare_for_query = false;                                                           \
        explicit managed(internal::bridge::obj&& obj,                 \
                     internal::bridge::realm realm)                  \
        : m_obj(std::move(obj))\
        , m_realm(std::move(realm))       \
        {     \
            std::apply([&](auto && ...ptr) { \
                std::apply([&](auto&& ..._name) { \
                ((*this.*ptr).assign(&m_obj, &m_realm, m_obj.get_table().get_column_key(_name)), ...); \
                }, managed_pointers_names); \
            }, managed_pointers()); \
        }                                                                                          \
        managed(const managed& other) { \
            m_obj = other.m_obj; \
            m_realm = other.m_realm;                                                               \
            m_prepare_for_query = other.m_prepare_for_query;                                     \
            if (m_prepare_for_query) {                                                                                       \
                auto schema = m_realm.schema().find(other.schema.name);                                  \
                auto group = m_realm.read_group();                                                   \
                auto table_ref = group.get_table(schema.table_key());                                  \
                std::apply([&](auto &&...ptr) {                                                        \
                    std::apply([&](auto &&..._name) {                                                   \
                        ((*this.*ptr).prepare_for_query(&m_realm, table_ref, _name), ...);                \
                    }, managed_pointers_names);                                                         \
                }, managed_pointers());                                                                 \
            } else {                                                                                      \
                std::apply([&](auto &&...ptr) { \
                    std::apply([&](auto &&..._name) { \
                    ((*this.*ptr).assign(&m_obj, &m_realm, m_obj.get_table().get_column_key(_name)), ...); \
                    }, managed_pointers_names); \
                }, managed_pointers());                                                                \
            }                                                                                       \
        } \
        managed& operator=(const managed& other) { \
            m_obj = other.m_obj; \
            m_realm = other.m_realm;                                                               \
            m_prepare_for_query = other.m_prepare_for_query;                                     \
             if (m_prepare_for_query) {                                                                                       \
                 auto schema = m_realm.schema().find(other.schema.name);                                  \
                 auto group = m_realm.read_group();                                                   \
                 auto table_ref = group.get_table(schema.table_key());                                  \
                 std::apply([&](auto &&...ptr) {                                                        \
                     std::apply([&](auto &&..._name) {                                                   \
                         ((*this.*ptr).prepare_for_query(&m_realm, table_ref, _name), ...);                \
                     }, managed_pointers_names);                                                         \
                 }, managed_pointers());                                                                 \
             } else {                                                                                      \
                 std::apply([&](auto &&...ptr) { \
                     std::apply([&](auto &&..._name) { \
                     ((*this.*ptr).assign(&m_obj, &m_realm, m_obj.get_table().get_column_key(_name)), ...); \
                     }, managed_pointers_names); \
                 }, managed_pointers());                                                                \
             }                                                                                       \
            return *this; \
        } \
        managed(managed&& other) { \
            m_obj = std::move(other.m_obj); \
            m_realm = std::move(other.m_realm);                                                    \
            m_prepare_for_query = std::move(other.m_prepare_for_query);                                     \
             if (m_prepare_for_query) {                                                                                       \
                 auto schema = m_realm.schema().find(other.schema.name);                                  \
                 auto group = m_realm.read_group();                                                   \
                 auto table_ref = group.get_table(schema.table_key());                                  \
                 std::apply([&](auto &&...ptr) {                                                        \
                     std::apply([&](auto &&..._name) {                                                   \
                         ((*this.*ptr).prepare_for_query(&m_realm, table_ref, _name), ...);                \
                     }, managed_pointers_names);                                                         \
                 }, managed_pointers());                                                                 \
             } else {                                                                                      \
                 std::apply([&](auto &&...ptr) { \
                     std::apply([&](auto &&..._name) { \
                     ((*this.*ptr).assign(&m_obj, &m_realm, m_obj.get_table().get_column_key(_name)), ...); \
                     }, managed_pointers_names); \
                 }, managed_pointers());                                                                \
             }                                                                                       \
        } \
        managed& operator=(managed&& other) { \
            m_obj = std::move(other.m_obj); \
            m_realm = std::move(other.m_realm);                                                   \
            m_prepare_for_query = std::move(other.m_prepare_for_query);                                     \
            if (m_prepare_for_query) {                                                                                       \
                auto schema = m_realm.schema().find(other.schema.name);                                  \
                auto group = m_realm.read_group();                                                   \
                auto table_ref = group.get_table(schema.table_key());                                  \
                std::apply([&](auto &&...ptr) {                                                        \
                   std::apply([&](auto &&..._name) {                                                   \
                     ((*this.*ptr).prepare_for_query(&m_realm, table_ref, _name), ...);                \
                   }, managed_pointers_names);                                                         \
                }, managed_pointers());                                                                 \
                } else {                                                                                      \
                   std::apply([&](auto &&...ptr) { \
                        std::apply([&](auto &&..._name) { \
                        ((*this.*ptr).assign(&m_obj, &m_realm, m_obj.get_table().get_column_key(_name)), ...); \
                    }, managed_pointers_names); \
                }, managed_pointers());                                                                \
            }  \
             return *this;\
        }                                                                                          \
        static managed prepare_for_query(const internal::bridge::realm& r) {                       \
            managed<cls> m;                                                                        \
            m.m_prepare_for_query = true;                                                          \
            m.m_realm = r;                                                                         \
            auto schema = m.m_realm.schema().find(m.schema.name);                                  \
            auto group = m.m_realm.read_group();                                                   \
            auto table_ref = group.get_table(schema.table_key());                                  \
            std::apply([&](auto && ...ptr) {                                                        \
                std::apply([&](auto&& ..._name) {                                                   \
                    ((m.*ptr).prepare_for_query(&m.m_realm, table_ref, _name), ...);                \
                }, managed_pointers_names);                                                         \
            }, managed_pointers());                                                                 \
            return m;                                                                                       \
        }                                                                                           \
        auto observe(std::function<void(realm::experimental::object_change<managed>&&)>&& fn) { \
            auto m_object = std::make_shared<internal::bridge::object>(m_realm, m_obj);                   \
            auto wrapper = realm::experimental::ObjectChangeCallbackWrapper<managed>{ \
            std::move(fn), this, m_object}; \
            return m_object->add_notification_callback( \
            std::make_shared<realm::experimental::ObjectChangeCallbackWrapper<managed>>(wrapper));                               \
        }                      \
        bool operator ==(const managed<cls>& other) const {                                                               \
            auto& a = m_obj; \
            auto& b = other.m_obj; \
            \
            if (m_realm != other.m_realm) { \
                return false; \
            } \
    \
            return a.get_table() == b.get_table() \
                   && a.get_key() == b.get_key(); \
        }                      \
        bool operator ==(const managed<cls*>& other) const {   \
            auto& a = m_obj; \
            auto& b = other.m_obj; \
            \
            if (m_realm != other->m_realm) { \
                return false; \
            } \
    \
            return a.get_table() == b->get_table() \
                   && a.get_key() == b->get_key(); \
        }                       \
    };                         \
    struct meta_schema_##cls {   \
        meta_schema_##cls() {                                                    \
            auto s = managed<cls>::schema.to_core_schema();                      \
            auto it = std::find(std::begin(realm::experimental::db::schemas), std::end(realm::experimental::db::schemas), s);                                  \
            if (it == std::end(realm::experimental::db::schemas))                                                                     \
                realm::experimental::db::schemas.push_back(s);       \
        }                     \
    }; \
    static inline meta_schema_##cls _meta_schema_##cls{};

#endif //CPPREALM_MACROS_HPP
